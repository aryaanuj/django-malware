from rest_framework import serializers
from .models import Product

# class ProductSerializer(serializers.Serializer):
# 	# validators
# 	def start_with_r(value):
# 		if value.lower()[0] != 'r':
# 			raise serializers.ValidationError("product_name must be start with r")
# 		return value

# 	id = serializers.IntegerField()
# 	product_name = serializers.CharField(max_length=100, validators=[start_with_r])
# 	price = serializers.IntegerField()
# 	desc = serializers.CharField(max_length=100)

# 	# for adding data
# 	def create(self, validated_data):
# 		return Product.objects.create(**validated_data)

# 	# for updating data
# 	def update(self, instance, validated_data):
# 		# instance represent the current modelobject
# 		instance.product_name = validated_data.get('product_name', instance.product_name)
# 		instance.price = validated_data.get('price', instance.price)
# 		instance.desc = validated_data.get('desc', instance.desc)
# 		instance.save()
# 		return instance

# 	# field level validation
# 	def validate_price(self, value):
# 		if value<2000:
# 			raise  serializers.ValidationError("Price should be more than 2000")
# 		return value

# 	# object level validation
# 	def validate(self, data):
# 		name = data.get('product_name')
# 		price = data.get('price')
# 		if name=='redme' and price != '4000':
# 			raise serializers.ValidationError('redme phone price must be 4000')
# 		return data



# using ModelSerializer

class ProductSerializer(serializers.ModelSerializer):
	# 1st way of validation 
	# product_name = serializers.CharField(read_only=True)
	class Meta:
		model = Product
		fields = ['id', 'product_name', 'price', 'desc']
		# 2nd way of validataion
		# read_only_fields = ['product_name', 'price']

		# 3rd way of validataion
		# extra_kwargs = {'product_name':{'read_only':True}}